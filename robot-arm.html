<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Control</title>
</head>
<body>

<nav>
  <a href="index.html">Home</a>
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Control System</h1>

<h2>Overview</h2>
<p>
This project implements real-time cartesian control of a 3-DOF robotic arm using a Jacobian based inverse kinematics "solver", PID controls for cartesian commands, and a singularity detection/avoidance system.
</p>

<h2>System Design</h2>
<ul>
  <li>Forward and inverse kinematics</li>
  <li>Jacobian matrix and damped least squares</li>
  <li>Workspace-based controls rather than jointspace-based controls</li>
  <li>PID control for workspace commands with variable time step</li>
  <li>Singularity detection using principles derived from singular value decomposition</li>
  <li>Singularity avoidance using positional awareness and motion redirection</li>
</ul>
<h2>Motivation and Problem Statement</h2>
<p>
The goal of this project was to design and program a robotic arm with rotational joints that could be controlled in the direction of an arbitrary vector in ℝ³,
rather than through direct joint angle commands. This framing shifts the control problem from joint space to task space and requires the use of kinematics, Jacobians,
and feedback control.

I pursued this project to reinforce and integrate concepts from multivariable calculus, linear algebra, statics, and introductory C programming, all of which I had
completed in the preceding semester. Rather than treating these topics independently, the intent was to apply them to a single, constrained physical system.

The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor. This configuration represents the minimum number of joints 
required to span a three-dimensional workspace while avoiding redundancy and the need for null-space optimization. These constraints simplified the kinematic structure 
while still allowing meaningful exploration of inverse kinematics and singularity behavior.

Hardware limitations significantly influenced the control strategy. The Arduino’s limited computational resources imposed practical constraints on numerical precision 
and algorithmic complexity, while the servos’ integer-degree position resolution introduced quantization error that directly affected end-effector tracking accuracy. 
These limitations highlighted the tradeoffs between theoretical control design and embedded implementation and informed several design decisions discussed later.
</p>
<h2>System Architecture Overview</h2>
<p>
Mechanical System-
  The body of my robot was built from PETG filament out of pieces designed and manufactured by myself. I decided to use a 3d printer for the manufacturing of this project so that
  I could leverage prior experience with SolidWorks and have better control over motor mounts, joint interfaces and general link geometry. As for filament choice, price constraints forced 
  me to choose between PLA and PETG, I chose PETG due to its higher toughness and resistance to brittle failure. While PLA granted higher stiffness, PETGs increased ductility made it 
  preferrable to a system that could experience repeated loadingand future payload expansion.
Electronics and Hardware-
  The control hardware consists of an Arduino Uno microcontroller, two SG90 hobby servos, and a 28BYJ-48 stepper motor. Component selection was constrained by the contents of the electronic starter kit I had
  purchased, intentionally prioritizing accessibility and cost over performance. This constraint forced the control system to operate under limited positional resolution, torque output, and computational capacity,
  making it well-suited for studying the practical limitations of embedded control systems. A solderless breadboard was used to facilitate rapid iteration and debugging during development.
Software Architecture-
  The software was developed iteratively, with an emphasis on modularity and testability. At a high level, the control loop follows this sequence:
    Initialize joint states and system parameters,
    Compute forward kinematics,
    Accept a user-defined direction vector in task space,
    Apply PID control in Cartesian space to reduce positional error,
    Compute joint updates using a damped least-squares Jacobian-based inverse kinematics solver,
    Detect proximity to kinematic singularities,
    Command joint actuators to the updated positions,
Each functional block was designed to be as independent as possible, allowing individual components to be tested in isolation. This architecture enabled debugging and validation of the kinematic and control
logic without requiring the physical hardware to be connected.
</p>
<h2>Mechanical Design</h2>
<p>
  My robotic arm assembly consisted of 3 simple pieces. The base was built with 3 legs to ensure stability and measurements to ensure the stepper motor could feed through it. The two links were designed largely in tandem and begun with a length of 200mm
  this was almost immediately shortened dramatically to 80mm due to torque constraints. Link 1 was designed to fit on top of a servo with a servo horn already attached, link 1 also features a bracket designed to house another servo. link 2 was derived from 1,
  differing in its end where a pointer sits to accurately reflect where the robot thinks the end effector is.
</p>

  
<h2>Demo Video</h2>
<video width="640" controls>
  <source src="assets/videos/robot-demo.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<h2>What Went Wrong</h2>
<p>
Instability occurred near joint limits and Jacobian singularities,
requiring damping and timing corrections.
</p>

</body>
</html>
