<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Mechanical Design and Control System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

<nav>
  <a href="index.html">Home</a> |
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Mechanical Design and Control System</h1>
  <p>By Arthur Hafliger</p>
  <p>Project start: December 2025</p>
  <p>Project completion: ongoing</p>
  <p>Note: though the project is ongoing, all the following represents the system in its current state</p>

<section>
  <h2>Overview</h2>
  <p>
    This project demonstrates real-time Cartesian control of a 3-DOF robotic arm using a Jacobian-based inverse kinematics solver, task-space PID control, and a singularity detection and avoidance strategy. The system integrates mechanical design, electronics, and embedded control software to achieve accurate end-effector motion within a constrained workspace.
  </p>
  <figure>
    <img src="RobotArmRobotArm.jpeg" alt="Isometric view of robot" width="650">
    <figcaption>3 DOF Robot Arm.</figcaption>
  </figure>
</section>
  <section>
  <h2>Why This Project Matters</h2>
  <p>
    Cartesian control and singularity management are fundamental challenges in real-world robotic systems, including industrial manipulators, collaborative robots, and medical devices. While these topics are often introduced theoretically, implementing them on embedded hardware exposes practical issues such as numerical instability, electronic restrictions, and computational limits.
  </p>
  <p>
    This project demonstrates how control concepts such as Jacobian-based inverse kinematics, damped least squares, and task-space PID control can be adapted to low-cost hardware with limited precision. By explicitly addressing singularity detection, avoidance, and recovery, the system prioritizes robustness over idealized performance.
  </p>
  <p>
    Beyond achieving end-effector motion, this work emphasizes system-level engineering: understanding failure modes, making design tradeoffs, and validating behavior through physical experiments.
  </p>
</section>


<section>
  <h2>System Design Summary</h2>
  <ul>
    <li><strong>Forward and inverse kinematics:</strong> Provides the mathematical mapping between joint angles and end-effector position.</li>
    <li><strong>Jacobian formulation with damped least squares:</strong> Ensures stable inversion near singularities and enables task-space velocity control.</li>
    <li><strong>Task-space control:</strong> Commands the end-effector directly, simplifying motion planning compared to joint-space control.</li>
    <li><strong>PID control for Cartesian commands with variable timestep:</strong> Corrects errors in real time while accounting for non-uniform loop intervals.</li>
    <li><strong>Singularity detection using eigenvalue approximations:</strong> Identifies configurations where the robot loses degrees of freedom without full SVD computation.</li>
    <li><strong>Singularity avoidance through motion redirection:</strong> Maintains smooth operation near critical configurations.</li>
  </ul>
</section>

<section>
  <h2>Motivation and Problem Statement</h2>
  <p>
    The goal of this project was to design and program a robotic arm with rotational joints that can move its end-effector along an arbitrary vector in ℝ³, rather than commanding individual joint angles directly. This approach transforms the control problem from joint space to task space, requiring careful consideration of kinematics, Jacobians, and feedback control.
  </p>

  <p>
    This project also provided an opportunity to integrate concepts from multivariable calculus, linear algebra, statics, and introductory C programming (class I had taken in the previous semester) into a single physical system, bridging the gap between theory and practical implementation.
  </p>

  <p>
    The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor. This configuration represents the minimum number of joints required to span a three-dimensional workspace while avoiding redundancy and null-space optimization.
  </p>

  <p>
    Hardware limitations strongly influenced the control strategy. The Arduino’s limited computational resources imposed constraints on numerical precision and algorithmic complexity. Similarly, the servos’ integer-degree resolution introduced quantization errors affecting end-effector accuracy. These limitations highlighted trade-offs between theoretical design and embedded implementation.
  </p>
</section>

<section>
  <h2>System Architecture Overview</h2>

  <h3>Mechanical Design and Power Transmission</h3>
  <figure>
    <img src="RobotArmIso.png" alt="Isometric view of robotic arm assembly" width="650">
    <figcaption>Isometric view of the robotic arm SolidWorks assembly.</figcaption>
  </figure>

  <h3>Design Goals and Constraints</h3>
  <p>
    The mechanical design was constrained by actuator torque limits, 3D-printable geometry, and the requirement for repeatable rotational motion across all three degrees of freedom. Components were manufactured in-house using PETG filament, emphasizing modularity and ease of iteration. The stepper motor CAD model was imported from GrabCAD.com (user: Vladimir Rovinskiy).
  </p>
  <p>
    Mechanical design decisions directly affected control performance. Backlash, actuator limitations, and 3D-printed tolerances were considered during kinematics validation and PID tuning.
  </p>

  <h3>Base Rotation and Drive System</h3>
  <p>
    The base functions as a bearing-driven rotating platform. A stepper motor in the stationary base drives a bevel gear, which meshes with a second bevel gear rigidly attached to the rotating base. This separates load-bearing and torque transmission: bearings support axial and radial loads, while the bevel gear transmits rotational motion. This design improves rotational stability compared to direct shaft mounting and mirrors industrial rotary joint architectures.
  </p>
  <figure>
    <img src="RobotArmExplodeBase.png" alt="Exploded view of base assembly" width="650">
    <figcaption>Exploded view of the base assembly.</figcaption>
  </figure>

  <h3>Link Geometry and Joint Layout</h3>
  <p>
    The manipulator has two serially connected links mounted above the rotating base, forming a 3-DOF arm. Initial link lengths of 200 mm were reduced to 80 mm after testing actuator limitations.
  </p>
  <p>
    The first link mounts directly to a servo horn and includes a bracket for the second servo. The second link includes a pointer for visually validating end-effector position.
  </p>
  <figure>
    <img src="RobotArmExplodeArm.png" alt="Exploded view of arm assembly" width="650">
    <figcaption>Exploded view of arm assembly.</figcaption>
  </figure>

  <h3>Materials and Manufacturing</h3>
  <p>
    Components were 3D-printed from PETG for increased toughness and resistance to brittle failure. Careful attention to tolerances, fastener placement, and assembly order ensured correct interfacing with electronics.
  </p>

  <h3>Mechanical Limitations</h3>
  <p>
    Limitations include actuator torque constraints, backlash in 3D-printed gears, and the lack of integrated wire management. These factors affect workspace and control performance and inform proposed improvements.
  </p>
</section>

<section>
  <h2>Electronics and Hardware</h2>
  <p>
    Control hardware includes an Arduino Uno, two SG90 servos, and a 28BYJ-48 stepper motor. Components were chosen for accessibility and cost-effectiveness.
  </p>
  <p>
    The Arduino operates at ~16 MHz, limiting real-time performance. Servos provide ~1° resolution, introducing quantization errors. A solderless breadboard facilitated rapid iteration and debugging.
  </p>
  <p>For the purposes of additional button inputs, an Arduino Mega was used in the final iteration of this project though it is important to note that everything is fully functional on a standard Arduino Uno</p>
  <figure>
    <img src="image2.jpeg" alt="MicroController" width="650">
    <figcaption>Arduino Mega clone (Elegoo Mega) used in final iteration.</figcaption>
  </figure>
  <figure>
    <img src="RobotArmBreadSquare.jpeg" alt="Electronic wiring" width="650">
    <figcaption>Top view of breadboard used to power the electronics. Connected to 5v and ground pins on the Microcontroller for power.</figcaption>
  </figure>
  <figure>
    <img src="RobotArmBreadBoard.jpeg" alt="Control wiring" width="650">
    <figcaption>Top view of breadboard used for user button inputs. All buttons connected to 3.3v and ground pins on the Microcontroller and wired through a 10k ohm resistor.</figcaption>
  </figure>
</section>

<section>
  <h2>Software Architecture</h2>
  <p>
    Software was developed iteratively for modularity and testability. The control loop follows this sequence:
  </p>
  <ol>
    <li>Initialize joint states and system parameters.</li>
    <li>Compute forward kinematics.</li>
    <li>Accept a user-defined velocity vector in task space.</li>
    <li>Compute the Jacobian matrix.</li>
    <li>Detect proximity to kinematic singularities.</li>
    <li>Correct the desired velocity vector using a PID controller.</li>
    <li>Solve the damped least-squares inverse kinematics problem for joint updates.</li>
    <li>Send updated joint angles to actuators.</li>
  </ol>
</section>

<section>
  <h2>Mathematics and Kinematics</h2>

  <h3>Forward Kinematics</h3>
  <p>
    Forward kinematics were derived by computing Cartesian coordinates as functions of joint angles. This maps joint space to task space.
  </p>
  <figure>
    <img src="image0 (1).jpeg" alt="Forward kinematics illustration" width="650">
    <figcaption>Graphical representation of forward kinematics.</figcaption>
  </figure>

  <h3>Inverse Kinematics</h3>
  <p>
    Initial solutions used trigonometry based on the robot’s geometry, effective for unit-vector commands but limited in generality.  
    A Jacobian-based inverse kinematics method was ultimately implemented, using local linearization to relate changes in end-effector position to joint angle changes.
  </p>
  <figure>
    <img src="imageJ1.jpeg" alt="Jacobian derivation" width="650">
    <figcaption>Hand-derived Jacobian relating joint velocities to end-effector velocity.</figcaption>
  </figure>
  <figure>
    <img src="imageJ2.jpeg" alt="Jacobian simplification" width="650">
    <figcaption>Simplified relationship between position changes and joint angle changes.</figcaption>
  </figure>

  <h3>Jacobian Solution and Damping</h3>
  <p>
    The inverse problem was solved using least-squares with damping to improve numerical stability near singularities.  
    The damping coefficient ensures the eigenvalues of J^T J remain positive, preventing instability.
  </p>
  <figure>
    <img src="imageLeastSquares.jpeg" alt="Least squares solution of Jacobian" width="650">
    <figcaption>Least-squares solution of the Jacobian matrix equation.</figcaption>
  </figure>
  <figure>
    <img src="imageDamp.jpeg" alt="Damped least squares illustration" width="650">
    <figcaption>Damping stabilizes inversion near singular configurations.</figcaption>
  </figure>

  <h3>Singularity Detection and Avoidance</h3>
  <p>
    Singularities are detected by monitoring the smallest singular value of the Jacobian. To reduce computation, eigenvalue-based approximations were used instead of full SVD.
  </p>
  <figure>
    <img src="imagePowerIteration.jpeg" alt="Eigenvalue-based singularity detection" width="650">
    <figcaption>Illustration of eigenvalue-based approximation for smallest singular value.</figcaption>
  </figure>
  <p>
    Singularities are avoided by placing a limit on the boundary and central region. All new motion that would pass this limit is rejected. The PID controller responds by turning off the derivative and integral term, heavily damping kP, and setting all error to zero. This eliminates any build-up of energy
    so that the manipulator can safely withdraw from the singular zone. 
  </p>
  <!-- Suggested: Include workspace and singularity visualization -->
</section>

<section>
  <h2>Control Strategy</h2>
  <h3>Initial Method</h3>
  <p>
    Positional Cartesian control with error correction was initially implemented. Commands were applied, and residual errors were corrected using a second inverse kinematics computation. Although accurate, this method caused drift due to mechanical limitations and required double computation per command, pushing the Arduino to its limits.
  </p>

  <h3>Current Method</h3>
  <p>
    Velocity-based Cartesian control with a PID loop is now used. A user-defined velocity vector is corrected for previous error, then translated into joint-space velocities using the Jacobian. Residual position errors are converted into additional joint adjustments via damped least-squares. Combining these produces final joint commands.
  </p>
  <p>
    This ensures the PID controller respects the robot’s kinematic constraints, preventing derivative wind-up near singularities. The Jacobian is computed once per loop, reducing computational load. Proportional control dominates due to actuator quantization; derivative action improves stability near singularities, and integral action is retained for future hardware upgrades.
  </p>
</section>

<section>
  <h2>Software Implementation</h2>
  <p>
    The system was programmed in Arduino C++ using the Arduino IDE. Libraries used include <code>Servo.h</code>, <code>math.h</code>, and <code>BasicLinearAlgebra.h</code>, allowing focus on control logic and integration.
  </p>
</section>

<section>
  <h2>Challenges and Failure Modes</h2>
  <p>
    Mechanical challenges included achieving precise tolerances with a consumer-grade 3D printer, especially for the base bearing. Sanding and fine adjustments were required for smooth rotation. Wire management was difficult and remains limited.
  </p>
  <p>
    Control challenges arose from discretizing continuous laws in embedded software. PID tuning and singularity detection introduced additional sources of error.
  </p>
</section>

<section>
  <h2>Results</h2>
  <p>
    Preliminary tests show stable Cartesian motion away from singularities. Quantitative performance metrics such as RMS tracking error are under evaluation.
  </p>
  <!-- Suggested: Include trajectory plots, error metrics, or demo video -->
</section>

<section>
  <h2>Future Improvements</h2>
  <ul>
    <li>Higher-precision actuators for improved tracking accuracy</li>
    <li>Implement motors with encoders to use PWM to better stabilize position</li>
    <li>Improved singularity handling</li>
    <li>Improved gear system on base assembly for reduced backlash and inprecision</li>
    <li>Redesigned mechanical structure with integrated wire management</li>
    <li>Wiring soldered to PCB/custom made PCB
    <li>Additional degrees of freedom enabling redundancy and null-space optimization</li>
    <li>Migration to a more powerful microcontroller, e.g., ESP32</li>
    <li>Wireless control and remote operation</li>
  </ul>
</section>

<section>
  <h2>Skills Demonstrated</h2>
  <ul>
    <li>Forward and inverse kinematics</li>
    <li>Jacobian-based control</li>
    <li>PID control systems</li>
    <li>Embedded systems programming</li>
    <li>C++ / Arduino development</li>
    <li>System integration and iterative design</li>
  </ul>
</section>

<section>
  <li>I highly encourage you the reader to reach out to me at ralphie0302@gmail.com with any critiques or questions</li>
</section>
  

<section>
  <h2>Demo Video</h2>
  <video width="640" controls>
    <source src="assets/videos/robot-demo.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</section>

</body>
</html>


