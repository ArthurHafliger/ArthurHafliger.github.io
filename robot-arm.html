<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Control</title>
</head>
<body>

<nav>
  <a href="index.html">Home</a>
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Control System</h1>

<h2>Overview</h2>
<p>
This project implements real-time cartesian control of a 3-DOF robotic arm using a Jacobian based inverse kinematics "solver", PID controls for cartesian commands, and a singularity detection/avoidance system.
</p>

<h2>System Design</h2>
<ul>
  <li>Forward and inverse kinematics</li>
  <li>Jacobian matrix and damped least squares</li>
  <li>Workspace-based controls rather than jointspace-based controls</li>
  <li>PID control for workspace commands with variable time step</li>
  <li>Singularity detection using principles derived from singular value decomposition</li>
  <li>Singularity avoidance using positional awareness and motion redirection</li>
</ul>
<h2>Motivation and Problem Statement</h2>
<p>
The goal of this project was to design and program a robotic arm with rotational joints that could be controlled in the direction of an arbitrary vector in ℝ³,
rather than through direct joint angle commands. This framing shifts the control problem from joint space to task space and requires the use of kinematics, Jacobians,
and feedback control.

I pursued this project to reinforce and integrate concepts from multivariable calculus, linear algebra, statics, and introductory C programming, all of which I had
completed in the preceding semester. Rather than treating these topics independently, the intent was to apply them to a single, constrained physical system.

The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor. This configuration represents the minimum number of joints 
required to span a three-dimensional workspace while avoiding redundancy and the need for null-space optimization. These constraints simplified the kinematic structure 
while still allowing meaningful exploration of inverse kinematics and singularity behavior.

Hardware limitations significantly influenced the control strategy. The Arduino’s limited computational resources imposed practical constraints on numerical precision 
and algorithmic complexity, while the servos’ integer-degree position resolution introduced quantization error that directly affected end-effector tracking accuracy. 
These limitations highlighted the tradeoffs between theoretical control design and embedded implementation and informed several design decisions discussed later.
</p>
<h2>System Architecture Overview</h2>
<p>
Mechanical System-
  The body of my robot was built from PETG filament out of pieces designed and manufactured by myself. I decided to use a 3d printer for the manufacturing of this project so that
  I could take advantage of my prior experience in SolidWorks to design pieces exactly the way I wanted them. As for filament choice, price constraints forced me to choose between PLA and PETG, I chose
  PETG due to its lower rigidity and higher flexibility. For this project I wanted to create the arm so that it could support weight if I ever expanded the scope such that it would be required, therefore 
  PETG was preferrable.
Electronics and Hardware-
  The Microcontroller I chose for this project was an Arduino Uno. I chose to use an Arduino because of its wide range of libraries and general ease of use. The electronic components
  I chose were constrained entirely by what was included in my Arduino Starter kit, therefore I used two of the SG90 Servo motors and one 28BYJ-48 stepper motor. For my wiring I used
  a Solderless breadboard for its impermanence and general ease of tinkering.
Software Architecture-
  Programming this robot came in many iterations but the general flow was Initialize joint positions, compute forward kinematics, accept a user input (direction vector), plug this direction into PID controls to account for error,
  Compute inverse kinematics via damped least squares jacobian, Look for singularities, move joints to computed final positions. The intent of the program flow was to keep each block as independent from its neighboring blocks
  as possible so as to ensure clarity and ease of testing, for instance, this program was built to be tested without hardware to test on.
</p>
<h2>Mechanical Design</h2>
<p>
  My robotic arm assembly consisted of 3 simple pieces. The base was built with 3 legs to ensure stability and measurements to ensure the stepper motor could feed through it. The two links were designed largely in tandem and begun with a length of 200mm
  this was almost immediately shortened dramatically to 80mm due to torque constraints. Link 1 was designed to fit on top of a servo with a servo horn already attached, link 1 also features a bracket designed to house another servo. link 2 was derived from 1,
  differing in its end where a pointer sits to accurately reflect where the robot thinks the end effector is.
</p>

  
<h2>Demo Video</h2>
<video width="640" controls>
  <source src="assets/videos/robot-demo.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<h2>What Went Wrong</h2>
<p>
Instability occurred near joint limits and Jacobian singularities,
requiring damping and timing corrections.
</p>

</body>
</html>
