<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Mechanical Design and Control System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

<nav>
  <a href="index.html">Home</a> |
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Control System</h1>

<section>
  <h2>Overview</h2>
  <p>
    This project implements real-time Cartesian control of a 3-DOF robotic arm using a Jacobian-based inverse
    kinematics solver, Cartesian-space PID control, and a singularity detection and avoidance strategy.
  </p>

  <!-- Suggestion: Place a system-level photo or short demo GIF here -->
</section>

<section>
  <h2>System Design Summary</h2>
  <ul>
    <li>Forward and inverse kinematics</li>
    <li>Jacobian formulation with damped least squares</li>
    <li>Workspace-based (Cartesian) control rather than joint-space control</li>
    <li>PID control for Cartesian commands with variable timestep</li>
    <li>Singularity detection using principles derived from singular value decomposition</li>
    <li>Singularity avoidance using positional awareness and motion redirection</li>
  </ul>
</section>

<section>
  <h2>Motivation and Problem Statement</h2>
  <p>
    The goal of this project was to design and program a robotic arm with rotational joints that could be
    controlled in the direction of an arbitrary vector in ℝ³, rather than through direct joint angle commands.
    This framing shifts the control problem from joint space to task space and requires the use of kinematics,
    Jacobians, and feedback control.
  </p>

  <p>
    I pursued this project to reinforce and integrate concepts from multivariable calculus, linear algebra,
    statics, and introductory C programming, all of which I had completed in the preceding semester. Rather than
    treating these topics independently, the intent was to apply them to a single, constrained physical system.
  </p>

  <p>
    The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor.
    This configuration represents the minimum number of joints required to span a three-dimensional workspace
    while avoiding redundancy and the need for null-space optimization.
  </p>

  <p>
    Hardware limitations significantly influenced the control strategy. The Arduino’s limited computational
    resources imposed constraints on numerical precision and algorithmic complexity, while the servos’
    integer-degree position resolution introduced quantization error that directly affected end-effector
    tracking accuracy. These limitations highlighted the tradeoffs between theoretical control design and
    embedded implementation.
  </p>
</section>

<section>
  <h2>System Architecture Overview</h2>

  <section>
  <h2>Mechanical Design and Power Transmission</h2>

  <h3>Design Goals and Constraints</h3>
  <p>
    The mechanical design was driven by three primary constraints: limited actuator torque,
    3D-printable geometry, and the need for repeatable rotational motion in all three degrees
    of freedom. All components were designed and manufactured in-house using PETG filament,
    with an emphasis on modularity and ease of iteration.
  </p>

  <h3>Base Rotation and Drive System</h3>
  <p>
    The base of the robot was redesigned to function as a bearing-driven rotating platform.
    A stepper motor mounted in the stationary base drives a bevel gear, which meshes with a
    second bevel gear rigidly attached to the center race of the rotating base. This configuration
    allows the upper structure of the robot to rotate independently while maintaining axial
    alignment and load support.
  </p>

  <p>
    This design separates load-bearing and torque transmission functions: the bearing geometry
    supports axial and radial loads, while the bevel gear pair transmits rotational motion from
    the stepper motor. This approach improves rotational stability compared to direct shaft
    mounting and better reflects drivetrain architectures used in industrial rotary joints.
  </p>

  <!-- Suggestion: Include cross-sectional CAD or annotated photo of base assembly -->

  <h3>Link Geometry and Joint Layout</h3>
  <p>
    The manipulator consists of two serially connected links mounted above the rotating base,
    forming a three-degree-of-freedom arm. Initial link lengths of 200 mm were reduced to
    approximately 80 mm after testing revealed actuator limitations.
  </p>

  <p>
    The first link mounts directly to a servo horn and includes an integrated bracket for the
    second servo. The second link was derived from the same geometry and modified at the distal
    end to include a pointer for visually validating the estimated end-effector position.
  </p>

  <h3>Materials and Manufacturing</h3>
  <p>
    All structural components were manufactured from PETG using a consumer-grade 3D printer.
    PETG was selected over PLA due to its increased toughness and resistance to brittle failure,
    making it more suitable for repeated loading and iterative redesign.
  </p>

  <p>
    Designing components to interface with off-the-shelf electronics required careful
    consideration of tolerances, fastener placement, and assembly order. Calipers were used
    extensively to validate critical dimensions of electronics prior to printing.
  </p>

  <h3>Mechanical Limitations</h3>
  <p>
    The primary mechanical limitations of the system stem from actuator torque constraints,
    backlash in 3D-printed gear interfaces, and the absence of integrated wire management.
    These factors influenced both achievable workspace and control performance and inform
    several of the proposed future improvements.
  </p>
</section>


  <!-- Suggestion: Add exploded CAD view or rendered assembly here -->

  <h3>Electronics and Hardware</h3>
  <p>
    The control hardware consists of an Arduino Uno microcontroller, two SG90 hobby servos, and a 28BYJ-48
    stepper motor. Component selection was constrained by the contents of an electronics starter kit,
    intentionally prioritizing accessibility and cost over performance.
  </p>
  <p>
    These constraints resulted in limited positional resolution, torque output, and computational capacity,
    making the system well-suited for studying the practical limitations of embedded control. A solderless
    breadboard was used to facilitate rapid iteration and debugging.
  </p>

  <!-- Suggestion: Add wiring diagram or labeled electronics photo -->

  <h3>Software Architecture</h3>
  <p>
    The software was developed iteratively with an emphasis on modularity and testability. At a high level,
    the control loop follows this sequence:
  </p>

  <ol>
    <li>Initialize joint states and system parameters</li>
    <li>Compute forward kinematics</li>
    <li>Accept a user-defined direction vector in task space</li>
    <li>Apply Cartesian-space PID control to reduce positional error</li>
    <li>Compute joint updates using a damped least-squares Jacobian solver</li>
    <li>Detect proximity to kinematic singularities</li>
    <li>Command actuators to the updated joint positions</li>
  </ol>

  <p>
    Each functional block was designed to be as independent as possible, allowing individual components to be
    tested in isolation. This architecture enabled debugging and validation of the control logic without
    requiring the physical hardware to be connected.
  </p>

  <!-- Suggestion: Block diagram or flowchart -->
</section>

<section>
  <h2>Mathematics and Kinematics</h2>

  <h3>Forward Kinematics</h3>
  <p>
    Forward kinematics were derived by solving for each Cartesian coordinate as a function of the three joint
    angles. This formulation provides the mapping from joint space to task space.
  </p>
<figure>
  <img src="image0 (1).jpeg"
       alt="Forward Kinematics"
       width="650">
  <figcaption>
    Graphical representation of robotic arm with forward kinematics shown.
  </figcaption>
</figure>

  <h3>Inverse Kinematics</h3>
  <p>
    Initial inverse kinematics solutions were explored using trigonometric methods based on the robot’s
    specific geometry. While effective for unit-vector commands, this approach lacked generality.
  </p>
  <p>
    A Jacobian-based inverse kinematics method was ultimately implemented. This approach relies on local
    linearization of the end-effector motion and uses matrix equations to relate differential changes in
    position to changes in joint angles.
  </p>
   <figure>
  <img src="imageJ1.jpeg"
       alt="Derivation of the Jacobian"
       width="650">
  <figcaption>
    Hand-derived Jacobian relating joint velocities to Cartesian end-effector velocity.
  </figcaption>
</figure>
   <figure>
  <img src="imageJ2.jpeg"
       alt="Derivation of the Jacobian"
       width="650">
  <figcaption>
    simplification of the above, relating change in position to change in angles.
  </figcaption>
</figure>

  <h3>Jacobian Solution and Damping</h3>
  <p>
    Although the system is non-redundant and the Jacobian is theoretically invertible, the inverse problem
    was formulated as a least-squares solution to better align with industry practice and enable future
    expansion. A damping coefficient was introduced to improve numerical stability near singularities.
  </p>
 <figure>
  <img src="imageLeastSquares.jpeg"
       alt="Solving the matrix equation derived above as a least squares equation"
       width="650">
  <figcaption>
    Hand-derived Least squares solution for the jacobian matrix equation.
  </figcaption>
</figure>

  <figure>
  <img src="imageDamp.jpeg"
       alt="Display of Damped least squares"
       width="650">
  <figcaption>
    The added damping coefficient ensures the eigenvalues of J^T J remain positive. Without this coefficient, Matrix inversion
    becomes numerically unstable near singular regions.
  </figcaption>
</figure> 
  
  <h3>Singularity Detection and Avoidance</h3>
  <p>
    Singularities were detected by monitoring the smallest singular value of the Jacobian matrix. Computing
    a full singular value decomposition at runtime was avoided due to computational constraints; instead,
    eigenvalue-based methods were used to approximate proximity to singular configurations.
  </p>
   <figure>
  <img src="imagePowerIteration.jpeg"
       alt="Derivation of least singular value detection"
       width="650">
  <figcaption>
    Hand-derived explanation of how the largest eigenvector of a matrix can be found. to find the smallest Eigenvector and therefore smallest singular
    value it follows from this explanation that solving the augmented matrix [A,w2] and repeating the process would yield such a result.
  </figcaption>
</figure>
  <p>
    Avoidance strategies depend on the detected singularity type. Boundary singularities are handled by
    reversing the desired direction vector, while central singularities are avoided by redirecting motion
    tangentially. Damped least squares further smooths behavior in high-risk configurations.
  </p>

  <!-- Suggestion: Visuals of workspace, singular regions, and trajectories -->
</section>

<section>
  <h2>Control Strategy</h2>
    <h3>Intial Method</h3>
  <p>
    Positional cartesian controls paired with an error correction system was the first major control method. The method operates by taking in a
    cartesian position command, running inverse kinematics to move the bot to said position, then the bot compares its current position to what the commanded
    position was using vector projection and then runs inverse kinematics again this time in the direction of the error vector. While boasting a high accuracy, 
    this method was ultimately scrapped because the error vector movement was victim to the same mechanical issues as the initial movement vector, leading to unavoidable drift.
    This method also demanded computing inverse kinematics twice in one direction command, something extremely computationally taxing which pushed the arduino to its limit.
  </p>
    <h3>Current Method</h3>
  <p>
   Velocity-based cartesian controls utilize PID closed loop controls to "push and pull" the robot to its desired destination. This method operates by taking in a cartesian velocity
    command and converting it to a target position by multiplying said command by the time it took to run the command and adding the result to the previous target velocity. This target position
    is compared to the actual position of the bot and movement begins by correcting this error with a proportional, integral, and derivative term. This PID loop then computes the velocity to best
    correct the positonal error and passes the correction into inverse kinematics where movement begins. The motivation for this control scheme came from my interest in learning more about PID loops
    and desire to mimmic what would be used in industry or more complex designs. PID control offers natural damping and adjustments to working conditions, my electronics still limit the true realization
    of this but future modifications will notice. A difficulty in using this method properly was tracking the change in time between commands. Because the program does not know how long the next input 
    from the user will take the time had to be computed by taking the time at the beginning of the control loop and comparing it to the time at the beginning of the previous run of the loop. This 
    method also had the added challenge of tuning the weights of each term in PID, this meant closely paying attention to the bot until controls didnt feel too sluggish but also not too unpredictable.
    
  </p>
  
  <p>
    Due to actuator quantization and the absence of strong steady-state disturbances, the integral term
    provided limited benefit in this implementation. Despite these constraints, the control framework
    remains effective when tested in simulation and serves as a foundation for future iterations using
    higher-quality actuators.
  </p>
</section>

<section>
  <h2>Software Implementation</h2>
  <p>
    The system was programmed using Arduino C++ within the Arduino IDE. Libraries such as
    <code>Servo.h</code>, <code>math.h</code>, and <code>BasicLinearAlgebra.h</code> were used to reduce
    implementation overhead and focus development on control logic and system integration.
  </p>
</section>

<section>
  <h2>Challenges and Failure Modes</h2>
  <p>
    Mechanical challenges included designing 3D-printed components with tight dimensional tolerances to
    interface correctly with electronic hardware. Wire management also proved difficult and is not fully
    addressed in the current design.
  </p>
  <p>
    From a control perspective, integrating continuous mathematics into discrete-time embedded software
    required numerical solutions for PID control and singularity detection, introducing additional sources
    of error.
  </p>
</section>

<section>
  <h2>Results</h2>
  <p>
    Experimental testing is ongoing. Preliminary results demonstrate stable Cartesian motion away from
    singular configurations.
  </p>

  <!-- Suggestion: Add trajectory plots, error metrics, or videos -->
</section>

<section>
  <h2>Future Improvements</h2>
  <ul>
    <li>Higher-precision actuators for improved tracking accuracy</li>
    <li>Redesigned mechanical structure with integrated wire management</li>
    <li>Additional degrees of freedom enabling redundancy and null-space optimization</li>
    <li>Migration to a more powerful microcontroller such as an ESP32</li>
    <li>Wireless control</li>
  </ul>
</section>

<section>
  <h2>Skills Demonstrated</h2>
  <ul>
    <li>Forward and inverse kinematics</li>
    <li>Jacobian-based control</li>
    <li>PID control systems</li>
    <li>Embedded systems programming</li>
    <li>C++ / Arduino development</li>
    <li>System integration</li>
  </ul>
</section>

<section>
  <h2>Demo Video</h2>
  <video width="640" controls>
    <source src="assets/videos/robot-demo.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</section>

</body>
</html>

