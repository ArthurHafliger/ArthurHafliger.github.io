<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Mechanical Design and Control System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

<nav>
  <a href="index.html">Home</a> |
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Mechanical Design and Control System</h1>
  <p>By Arthur Hafliger</p>
  <p>Project start: December 2025</p>
  <p>Project completion: ongoing</p>
  <p>Note: though the project is ongoing, all the following represents the system in its current state</p>
  <h3>Source Code</h3>
<p>
  The full Arduino control program used for this project can be downloaded
  <a href="download.html">here</a>.
</p>


<section>
  <h2>Overview</h2>
  <p>
    This project demonstrates real-time Cartesian control of a 3-DOF robotic arm using a Jacobian-based inverse kinematics solver, task-space PID control, and a singularity detection and avoidance strategy. The system integrates mechanical design, electronics, and embedded control software to achieve accurate end-effector motion within a constrained workspace.
  </p>
  <figure>
    <img src="RobotArmRobotArm.jpeg" alt="Isometric view of robot" width="650">
    <figcaption>3 DOF Robot Arm.</figcaption>
  </figure>
</section>
  <section>
  <h2>Why This Project Matters</h2>
  <p>
    Cartesian control and singularity management are fundamental challenges in real-world robotic systems, including industrial manipulators, collaborative robots, and medical devices. While these topics are often introduced theoretically, implementing them on embedded hardware exposes practical issues such as numerical instability, electronic restrictions, and computational limits.
  </p>
  <p>
    This project demonstrates how control concepts such as Jacobian-based inverse kinematics, damped least squares, and task-space PID control can be adapted to low-cost hardware with limited precision. By explicitly addressing singularity detection, avoidance, and recovery, the system prioritizes robustness over idealized performance.
  </p>
  <p>
    Beyond achieving end-effector motion, this work emphasizes system-level engineering: understanding failure modes, making design tradeoffs, and validating behavior through physical experiments.
  </p>
</section>


<section>
  <h2>System Design Summary</h2>
  <ul>
    <li><strong>Forward and inverse kinematics:</strong> Provides the mathematical mapping between joint angles and end-effector position.</li>
    <li><strong>Jacobian formulation with damped least squares:</strong> Ensures stable inversion near singularities and enables task-space velocity control.</li>
    <li><strong>Task-space control:</strong> Commands the end-effector directly, simplifying motion planning compared to joint-space control.</li>
    <li><strong>PID control for Cartesian commands with variable timestep:</strong> Corrects errors in real time while accounting for non-uniform loop intervals.</li>
    <li><strong>Singularity detection using eigenvalue approximations:</strong> Identifies configurations where the robot loses degrees of freedom without full SVD computation.</li>
    <li><strong>Singularity avoidance through motion redirection:</strong> Maintains smooth operation near critical configurations.</li>
  </ul>
</section>


  <section> 
    <h2>Motivation and Problem Statement</h2>
    <p> 
      he goal of this project was to design and program a robotic arm with rotational joints that could be controlled in the direction of an arbitrary vector in ℝ³, rather than through direct joint angle commands. This framing shifts the control problem from joint space
      to task space and requires the use of kinematics, Jacobians, and feedback control. 
    </p> 
    <p> 
      I pursued this project to reinforce and integrate concepts from multivariable calculus, linear algebra, statics, and introductory C programming, all of which I had completed in the preceding semester. Rather than treating these topics independently, the intent was
      to apply them to a single, constrained physical system. 
    </p> 
    <p> 
      The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor. This configuration represents the minimum number of joints required to span a three-dimensional workspace while avoiding redundancy and the need for null-space optimization.
    </p>
    <p>
      Hardware limitations significantly influenced the control strategy. The Arduino’s limited computational resources imposed constraints on numerical precision and algorithmic complexity, while the servos’ integer-degree position resolution introduced quantization error that 
      directly affected end-effector tracking accuracy. These limitations highlighted the tradeoffs between theoretical control design and embedded implementation. 
    </p> 
  </section>

<section>
  <h4>System Architecture Overview</h4>

  <section> 
    <h2>Mechanical Design and Power Transmission</h2>
    <figure> <img src="RobotArmIso.png" alt="Isometric view" width="650"> <figcaption> 
      Isometric view of Robot Arm solidworks assembly. </figcaption>
    </figure> 
    <h1>Design Goals and Constraints</h1> 
    <p> 
      The mechanical design was driven by three primary constraints: limited actuator torque, 3D-printable geometry, and the need for repeatable rotational motion in all three degrees of freedom. All components were designed and manufactured in-house using PETG filament,
      with an emphasis on modularity and ease of iteration. Due to time constraints the Stepper motor CAD was imported from GrabCad.com from user Vladimir Rovinskiy.
    </p> 
    <h1>Base Rotation and Drive System</h1> 
    <p> 
      The base of the robot was redesigned to function as a bearing-driven rotating platform. A stepper motor mounted in the stationary base drives a bevel gear, which meshes with a second bevel gear rigidly attached to the center race of the rotating base. This configuration
      allows the upper structure of the robot to rotate independently while maintaining axial alignment and load support. 
    </p>
    <p> 
      This design separates load-bearing and torque transmission functions: the bearing geometry supports axial and radial loads, while the bevel gear 
      pair transmits rotational motion from the stepper motor. This approach improves rotational stability compared to direct shaft mounting and better reflects drivetrain architectures used in industrial rotary joints.
    </p> 
    <figure> <img src="RobotArmExplodeBase.png" alt="Exploded Base" width="650"> <figcaption> Exploded View of Base Assembly.
    </figcaption> 
    </figure>
    <h1>Link Geometry and Joint Layout</h1>
    <p> The manipulator consists of two serially connected links mounted above the rotating base, forming a three-degree-of-freedom arm. Initial link lengths of 200 mm were reduced to approximately 80 mm after testing revealed actuator limitations.
    </p>
    <p> 
      The first link mounts directly to a servo horn and includes an integrated bracket for the second servo. The second link was derived from the same geometry and modified at the distal end to include a pointer for visually validating the estimated end-effector position.
    </p> 
    <figure> <img src="RobotArmExplodeArm.png" alt="Exploded Arm" width="650"> <figcaption> Exploded View of Arm Assembly.
    </figcaption> 
    </figure> 
    <h1>Materials and Manufacturing</h1>
    <p> 
      All structural components were manufactured from PETG using a consumer-grade 3D printer. PETG was selected over PLA due to its increased toughness and resistance to brittle failure, making it more suitable for repeated loading and iterative redesign.
    </p> 
    <p> 
      Designing components to interface with off-the-shelf electronics required careful consideration of tolerances, fastener placement, and assembly order. Calipers were used extensively to validate critical dimensions of electronics prior to printing.
    </p> 
    <h1>Mechanical Limitations</h1>
    <p> 
      The primary mechanical limitations of the system stem from actuator torque constraints, backlash in 3D-printed gear interfaces, and the absence of integrated wire management. These factors influenced both achievable workspace and control performance and inform several of
      the proposed future improvements. 
    </p> 
  </section>

<section>
  <h3>Electronics and Hardware</h3> 
  <p> 
    The control hardware consists of an Arduino Mega microcontroller, two SG90 hobby servos, and a 28BYJ-48 stepper motor. Component selection was constrained by the contents of an electronics starter kit, intentionally prioritizing accessibility and cost over performance.
  </p>
  <p> 
    These constraints resulted in limited positional resolution, torque output, and computational capacity, making the system well-suited for studying the practical limitations of embedded control. A solderless breadboard was used to facilitate rapid iteration and debugging.
  </p>
  <p>
    For the purposes of additional button inputs, an Arduino Mega was used in the final iteration of this project though it is important to note that everything is fully functional on a standard Arduino Uno.
  </p>
  <figure>
    <img src="image2.jpeg" alt="MicroController" width="650">
    <figcaption>Arduino Mega clone (Elegoo Mega) used in final iteration.</figcaption>
  </figure>
  <figure>
    <img src="RobotArmBreadSquare.jpeg" alt="Electronic wiring" width="650">
    <figcaption>Top view of breadboard used to power the electronics. Connected to 5v and ground pins on the Microcontroller for power.</figcaption>
  </figure>
  <figure>
    <img src="RobotArmBreadBoard.jpeg" alt="Control wiring" width="650">
    <figcaption>Top view of breadboard used for user button inputs. All buttons connected to 3.3v and ground pins on the Microcontroller and wired through a 10k ohm resistor.</figcaption>
  </figure>
</section>

<section>
  <h2>Software Architecture</h2>
  <p>
    Software was developed iteratively for modularity and testability. The control loop follows this sequence:
  </p>
  <ol>
    <li>Initialize joint states and system parameters.</li>
    <li>Compute forward kinematics.</li>
    <li>Accept a user-defined velocity vector in task space.</li>
    <li>Compute the Jacobian matrix.</li>
    <li>Detect proximity to kinematic singularities.</li>
    <li>Correct the desired velocity vector using a PID controller.</li>
    <li>Solve the damped least-squares inverse kinematics problem for joint updates.</li>
    <li>Send updated joint angles to actuators.</li>
  </ol>
</section>

<section>
  <h3>Mathematics and Kinematics</h3> 
  <h1>Forward Kinematics</h1> 
  <p> Forward kinematics were derived by solving for each Cartesian coordinate as a function of the three joint angles. This formulation provides the mapping from joint space to task space. </p>
  <figure> 
    <img src="image0 (1).jpeg" alt="Forward Kinematics" width="650"> 
    <figcaption> Graphical representation of robotic arm with forward kinematics shown. </figcaption>
  </figure>
  <p>Forward Kinematics Code Snippet</p>
<pre><code class="language-cpp">
  c1 = cos(b); s1 = sin(b);
  c2 = cos(a1); s2 = sin(a1);
  c3 = cos(a2); s3 = sin(a2);
  *xd = L2*c3*c1 + L1*c2*c1; 
  *yd = L2*c3*s1 + L1*c2*s1;
  *zd = L2*s3     + L1*s2;
</code></pre>

  <h1>Inverse Kinematics</h1> 
  <p> 
    Initial inverse kinematics solutions were explored using trigonometric methods based on the robot’s specific geometry. While effective for unit-vector commands, this approach lacked generality.
  </p> 
  <p> 
    A Jacobian-based inverse kinematics method was ultimately implemented. This approach relies on local linearization of the end-effector motion and uses matrix equations to relate differential changes in position to changes in joint angles.
  </p> 
  <figure> <img src="imageJ1.jpeg" alt="Derivation of the Jacobian" width="650"> 
    <figcaption> Hand-derived Jacobian relating joint velocities to Cartesian end-effector velocity. </figcaption> 
  </figure> <figure> <img src="imageJ2.jpeg" alt="Derivation of the Jacobian" width="650"> <figcaption> simplification of the above, relating change in position to change in angles. </figcaption>
  </figure>
  <h1>Jacobian Solution and Damping</h1>
  <p> 
    Although the system is non-redundant and the Jacobian is theoretically invertible, the inverse problem was formulated as a least-squares solution to better align with industry practice and enable future expansion. A damping coefficient was introduced to improve numerical stability near singularities.
  </p> <figure> <img src="imageLeastSquares.jpeg" alt="Solving the matrix equation derived above as a least squares equation" width="650">
    <figcaption> Hand-derived Least squares solution for the jacobian matrix equation. </figcaption> </figure> <figure> <img src="imageDamp.jpeg" alt="Display of Damped least squares" width="650"> <figcaption> The added damping coefficient ensures the eigenvalues of J^T J remain positive. Without this coefficient,
      Matrix inversion becomes numerically unstable near singular regions. 
    </figcaption>
    </figure>
  <p>Inverse Kinematics Code Snippet</p>
<pre><code class="language-cpp">
  //Jacobian row x column;
  double J11 = -L1*sin(a1)*cos(b);
  double J12 = -L2*sin(a2)*cos(b);
  double J13 = -sin(b)*(L1*cos(a1)+L2*cos(a2));
  double J21 = -L1*sin(a1)*sin(b);
  double J22 = -L2*sin(a2)*sin(b);
  double J23 = cos(b)*(L1*cos(a1)+L2*cos(a2));
  double J31 = L1*cos(a1);
  double J32 = L2*cos(a2);
  double J33 = 0;

  Jcbn = {J11, J12, J13,
          J21, J22, J23,
          J31, J32, J33};
  JcbnT = {J11, J21, J31,
           J12, J22, J32,
           J13, J23, J33};
  
  Iden = {lambda*lambda, 0, 0,
          0, lambda*lambda, 0,
          0, 0, lambda*lambda};
  Matrix<3,3> JtJ = JcbnT*Jcbn;
  damp = JtJ + Iden; //Jacobian*Jacobian Transpose + Lambda^2 * Identity Matrix
  Invdamp = Inverse(damp); 

  DeltaP = getDirection(DirectionF, Position, &ErrorP, &TargetP, &iP, dt, sigmaMin);
  Delta0 = Invdamp*JcbnT*DeltaP;  //compute change in angles required
  Matrix<3,1> ActualDeltaP = Jcbn * Delta0; //compute what the change in position shouldve been
  Matrix<3,1> Residual = DeltaP - ActualDeltaP; //gather residual error from DLS
  Matrix<3,1> Delta0Correction = Invdamp * JcbnT * Residual; 
  Delta0 = Delta0 + Delta0Correction; 
</code></pre>

  <h1>Singularity Detection and Avoidance</h1> 
  <p> Singularities were detected by monitoring the smallest singular value of the Jacobian matrix. Computing a full singular value decomposition at runtime was avoided due to computational constraints; instead, eigenvalue-based methods were used to approximate proximity to singular configurations.
  </p> 
  <figure> <img src="imagePowerIteration.jpeg" alt="Derivation of least singular value detection" width="650"> <figcaption>
    Hand-derived explanation of how the largest eigenvector of a matrix can be found. To find the smallest Eigenvector and therefore smallest singular value it follows from this explanation that solving the augmented matrix [A,w2] and repeating the process would yield such a result. 
  </figcaption>
  </figure>
  <p> 
  Singularities were avoided by scaling the velocity input with respect to the current smallest singular value and neglecting some aspects of the PID controller when near a singular region. To avoid singularities geometrically, the system is restricted from moving into the outer region of the workspace
  and the inner cylinder of the workspace.
  </p>
  <figure> <img src="image0 (2).jpeg" alt="Visual representation of workspace boundary" width="650"> <figcaption>
    White board drawing of the workspace in the XY and ZX planes. Bottom left depicts a 3d view of the cylindrical center boundary that is also visible in the ZX plane. 
  </figcaption>
  </figure>
    <p>Singularity Detection Code Snippet</p>
<pre><code class="language-cpp">
  Matrix<3,3> A = Jcbn*JcbnT;
  Matrix<3,1> w;
  //solve Ax = w where x is any random vector
  
  Matrix<3,1> x = {1,1,1};
  Matrix<3,3> IdenSmall = {0.00001, 0, 0,
                          0, 0.00001, 0,
                          0, 0, 0.00001};
  // Regularization to avoid singularity
  A = A + IdenSmall;
  Matrix<3,3> Ai = Inverse(A);
  for(int i = 0; i<4; i++){
    // Solve A w = x using the inverse
    w = Ai * x;
    float mag = 1/sqrt(w(0,0)*w(0,0) + w(1,0)*w(1,0) + w(2,0)*w(2,0));
    w = {w(0,0)*mag, w(1,0)*mag, w(2,0)*mag};
    x = w;
  }
  Matrix<1,1> Eig = (~w)*(Inverse(A))*w;
  float sigmaMin = sqrt(Eig(0,0));
</code></pre>

<section>
<h3>Control Strategy</h3> 
<h1>Intial Method</h1> 
  <p> 
    Positional cartesian controls paired with an error correction system was the first major control method. The method operates by taking in a cartesian position command, running inverse kinematics to move the bot to said position, then the bot compares its current position to what the commanded position
    was using vector projection and then runs inverse kinematics again this time in the direction of the error vector. While boasting a high accuracy, this method was ultimately scrapped because the error vector movement was victim to the same mechanical issues as the initial movement vector, leading to 
    unavoidable drift. This method also demanded computing inverse kinematics twice in one direction command, something extremely computationally taxing which pushed the arduino to its limit. 
  </p> 
  <h1>Current Method</h1> 
  <p> 
    Velocity-based cartesian controls utilize PID closed loop controls to "push and pull" the robot to its desired destination. This method operates by accepting a user defined velocity vector which is then passed into an inverse kinematics solver function where the jacobian matrix is initialized. The desired
    velocity vector is then passed into a PID controller where it is then corrected with respect to the previous error. With this corrected velocity vector the change in angles vector is computed. Utilizing the same jacobian initialized before, the velocity vector is re-derived by solving for it with respect 
    to the change in angle vector which produces a residual change in position. This residual change in position is used to solve for a residual change in angles via the same damped least squares solver. The original change in angles vector is combined with this residual vector to find a final change in angles 
    vector. This method ensures that the PID controller is fully aware of the jacobian because its error is computed after the residual vectors are accounted for. Previous iterations of this method placed the PID controller before the jacobian computation, which caused errors in that the PID controls would make 
    changes without regard to positional capabilities, leading to derivative wind up and major build ups of energy near singular positions. The major benefit of this method over purely cartesian commands is that the jacobian is only computed once which saves major computational space. </p> <p> Ultimately, a 
    velocity-based Cartesian PID controller was implemented to compute corrective task-space velocities based on positional error. While proportional control dominated performance due to actuator quantization and limited steady-state disturbances, derivative damping improved stability near singular regions. 
    Integral action provided limited benefit under current hardware constraints but remains part of the framework for future iterations. </p> </section>
<p>PID Controller Code Snippet</p>
<pre><code class="language-cpp">
  float kP = 0.06;
  float kD = 0.003;
  float kI = 0.0001;
  Target = *TargetP + DirectionS*(Matrix<1,1> {dt}); //integrate directionS to get units of position

  }
  Matrix<3,1> actual = Position;
  
  Matrix<3,1> e = Target - actual;
  Matrix<3,1> d = (e - *ErrorP)*(Matrix<1,1> {1/dt});
  Matrix<3,1> i = *iP + e*(Matrix<1,1> {dt});
  
  Matrix<3,1> u = e*(Matrix<1,1> {kP}) + d*(Matrix<1,1> {kD}) + i*(Matrix<1,1> {kI});
</code></pre>
<section>
  <h2>Software Implementation</h2>
  <p>
    The system was programmed in Arduino C++ using the Arduino IDE. Libraries used include <code>Servo.h</code>, <code>math.h</code>, and <code>BasicLinearAlgebra.h</code>, allowing focus on control logic and integration.
  </p>
</section>

<section> 
  <h2>Challenges and Failure Modes</h2>
  <p> 
    Mechanical challenges included designing 3D-printed components with tight dimensional tolerances to interface correctly with electronic hardware. Wire management also proved difficult and is not fully addressed in the current design. Designing the base assembly proved especially challenging due to the extremely
    demanding tolerances of a bearing. The 3d printer used for this project would tend to over or under extrude in certain areas leaving final prints very rough. All pieces of the bearing assembly required lots of sanding and chiseling while requiring the patience to never overwork one specific area, The smallest 
    difference in texture proved to be the difference between a smooth and rough bearing. </p> 
  <p> 
    From a control perspective, integrating continuous mathematics into discrete-time embedded software required numerical solutions for PID control and singularity detection, introducing additional sources of error. When implementing the PID controller it was extremely challenging to make sure the error correction
    did not clash with the jacobian. Near singular regions a controller that does not realize the limited capabilities of movement will continue to build error when there isnt any movement available. As explained above, finding the position residue was the solution to this problem. Detecting the singularities along
    workspace boundaries is only half the challenge with singularities. Computing the determinant of the jacobian and finding all values where it equals zero proves that singularities exist in other far more rare configurations. My program fails to address the singularity that occurs when angles a1 and a2 are equal
    though in operation of my robot, this had never actually been observed.
  </p> 
</section>

<section>
  <h2>Results</h2>
  <p>
    The following are several videos depicting motion in cartesian space
  </p>
  <section>
  <h2>X Direction</h2>
  <video width="640" controls preload="metadata">
    <source src="Robotarmx.mp4" type="video/mp4">
    Depicts moving forward and reverse in the X direction, then traveling until the boundary singularity is hit to demonstrate recovery.
  </video>
</section>
  <p>Depicts moving forward and reverse in the X direction, then traveling until the boundary singularity is hit to demonstrate recovery.</p>
  <section>
  <h2>Y Direction</h2>
  <video width="640" controls preload="metadata">
    <source src="Robotarmy.mp4" type="video/mp4">
    Depicts moving forward and reverse in the Y direction, then traveling until the boundary singularity is hit to demonstrate recovery.
  </video>
</section>
  <p>Depicts moving forward and reverse in the Y direction, then traveling until the boundary singularity is hit to demonstrate recovery.</p>
  <section>
  <h2>Z Direction</h2>
  <video width="640" controls preload="metadata">
    <source src="Robotarmz.mp4" type="video/mp4">
    Depicts moving forward and reverse in the Z direction, then traveling until the boundary singularity is hit to demonstrate recovery.
  </video>
</section>
  <p>Depicts moving forward and reverse in the Z direction, then traveling until the boundary singularity is hit to demonstrate recovery.</p>
  <section>
  <h2>Cartesian Manipulation</h2>
  <video width="640" controls preload="metadata">
    <source src="Robotarmcart.mp4" type="video/mp4">
    Depicts moving in all directions according to user commands. This video highlights how singularities can be accidentally hit, how PID can
    misunderstand directional intention and carry momentum from previous directional inputs, and how PID can store energy near singular regions.
    This video purposefully highlights the imperfections of the system and will serve as a comparison for later iterations of this project.
  </video>
</section>
  <p>Depicts moving in all directions according to user commands. This video highlights how singularities can be accidentally hit, how PID can
    misunderstand directional intention and carry momentum from previous directional inputs, and how PID can store energy near singular regions.
    This video purposefully highlights the imperfections of the system and will serve as a comparison for later iterations of this project.</p>
  <!-- Suggested: Include trajectory plots, error metrics, or demo video -->
</section>
  <section>
  <h2>Circle</h2>
  <video width="640" controls preload="metadata">
    <source src="Circle.mp4" type="video/mp4">
    Depicts moving in a Circle.
  </video>
</section>
  <p>Depicts moving in a Circle.</p>

<section>
  <h2>Future Improvements</h2>
  <ul>
    <li>Higher-precision actuators for improved tracking accuracy</li>
    <li>Implement motors with encoders to use PWM to better stabilize position</li>
    <li>Improved singularity handling</li>
    <li>Improved gear system on base assembly for reduced backlash and inprecision</li>
    <li>Redesigned mechanical structure with integrated wire management</li>
    <li>Wiring soldered to PCB/custom made PCB
    <li>Additional degrees of freedom enabling redundancy and null-space optimization</li>
    <li>Migration to a more powerful microcontroller, e.g., ESP32</li>
    <li>Wireless control and remote operation</li>
  </ul>
</section>

<section>
  <h2>Skills Demonstrated</h2>
  <ul>
    <li>Forward and inverse kinematics</li>
    <li>Jacobian-based control</li>
    <li>PID control systems</li>
    <li>Embedded systems programming</li>
    <li>C++ / Arduino development</li>
    <li>System integration and iterative design</li>
  </ul>
</section>

<section>
  <li>I highly encourage you the reader to reach out to me at ralphie0302@gmail.com with any critiques or questions</li>
</section>
  



</body>
</html>


