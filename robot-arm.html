<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Control System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

<nav>
  <a href="index.html">Home</a> |
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Control System</h1>

<section>
  <h2>Overview</h2>
  <p>
    This project implements real-time Cartesian control of a 3-DOF robotic arm using a Jacobian-based inverse
    kinematics solver, Cartesian-space PID control, and a singularity detection and avoidance strategy.
  </p>

  <!-- Suggestion: Place a system-level photo or short demo GIF here -->
</section>

<section>
  <h2>System Design Summary</h2>
  <ul>
    <li>Forward and inverse kinematics</li>
    <li>Jacobian formulation with damped least squares</li>
    <li>Workspace-based (Cartesian) control rather than joint-space control</li>
    <li>PID control for Cartesian commands with variable timestep</li>
    <li>Singularity detection using principles derived from singular value decomposition</li>
    <li>Singularity avoidance using positional awareness and motion redirection</li>
  </ul>
</section>

<section>
  <h2>Motivation and Problem Statement</h2>
  <p>
    The goal of this project was to design and program a robotic arm with rotational joints that could be
    controlled in the direction of an arbitrary vector in ℝ³, rather than through direct joint angle commands.
    This framing shifts the control problem from joint space to task space and requires the use of kinematics,
    Jacobians, and feedback control.
  </p>

  <p>
    I pursued this project to reinforce and integrate concepts from multivariable calculus, linear algebra,
    statics, and introductory C programming, all of which I had completed in the preceding semester. Rather than
    treating these topics independently, the intent was to apply them to a single, constrained physical system.
  </p>

  <p>
    The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor.
    This configuration represents the minimum number of joints required to span a three-dimensional workspace
    while avoiding redundancy and the need for null-space optimization.
  </p>

  <p>
    Hardware limitations significantly influenced the control strategy. The Arduino’s limited computational
    resources imposed constraints on numerical precision and algorithmic complexity, while the servos’
    integer-degree position resolution introduced quantization error that directly affected end-effector
    tracking accuracy. These limitations highlighted the tradeoffs between theoretical control design and
    embedded implementation.
  </p>
</section>

<section>
  <h2>System Architecture Overview</h2>

  <h3>Mechanical System</h3>
  <p>
    The robot structure was manufactured from PETG filament using a consumer-grade 3D printer. All components
    were designed in SolidWorks, allowing precise control over motor mounts, joint interfaces, and link
    geometry.
  </p>
  <p>
    PETG was selected over PLA due to its higher toughness and resistance to brittle failure. While PLA offers
    greater stiffness, PETG’s increased ductility made it more suitable for a system expected to experience
    repeated loading and potential future payload expansion.
  </p>

  <!-- Suggestion: Add exploded CAD view or rendered assembly here -->

  <h3>Electronics and Hardware</h3>
  <p>
    The control hardware consists of an Arduino Uno microcontroller, two SG90 hobby servos, and a 28BYJ-48
    stepper motor. Component selection was constrained by the contents of an electronics starter kit,
    intentionally prioritizing accessibility and cost over performance.
  </p>
  <p>
    These constraints resulted in limited positional resolution, torque output, and computational capacity,
    making the system well-suited for studying the practical limitations of embedded control. A solderless
    breadboard was used to facilitate rapid iteration and debugging.
  </p>

  <!-- Suggestion: Add wiring diagram or labeled electronics photo -->

  <h3>Software Architecture</h3>
  <p>
    The software was developed iteratively with an emphasis on modularity and testability. At a high level,
    the control loop follows this sequence:
  </p>

  <ol>
    <li>Initialize joint states and system parameters</li>
    <li>Compute forward kinematics</li>
    <li>Accept a user-defined direction vector in task space</li>
    <li>Apply Cartesian-space PID control to reduce positional error</li>
    <li>Compute joint updates using a damped least-squares Jacobian solver</li>
    <li>Detect proximity to kinematic singularities</li>
    <li>Command actuators to the updated joint positions</li>
  </ol>

  <p>
    Each functional block was designed to be as independent as possible, allowing individual components to be
    tested in isolation. This architecture enabled debugging and validation of the control logic without
    requiring the physical hardware to be connected.
  </p>

  <!-- Suggestion: Block diagram or flowchart -->
</section>

<section>
  <h2>Mechanical Design</h2>
  <p>
    The robotic arm consists of a fixed base and two serially connected links, forming a three-degree-of-
    freedom manipulator. The base features three supporting legs for stability and includes a central cutout
    to accommodate the stepper motor shaft.
  </p>

  <p>
    The initial link length was set to 200 mm but was reduced to approximately 80 mm after preliminary testing
    revealed torque limitations in the actuators. Link 1 mounts directly to a servo horn and includes an
    integrated bracket to house the second servo. Link 2 was derived from Link 1’s geometry and modified at the
    distal end to include a pointer used for visually verifying the estimated end-effector position.
  </p>

  <!-- Suggestion: Add dimensioned drawings or torque analysis snapshot -->
</section>

<section>
  <h2>Mathematics and Kinematics</h2>

  <h3>Forward Kinematics</h3>
  <p>
    Forward kinematics were derived by solving for each Cartesian coordinate as a function of the three joint
    angles. This formulation provides the mapping from joint space to task space.
  </p>

  <figure>
  <img src="assets/images/jacobian-derivation.jpg"
       alt="Derivation of the Jacobian mapping joint velocities to end-effector velocity"
       width="650">
  <figcaption>
    Hand-derived Jacobian relating joint velocities to Cartesian end-effector velocity.
    This formulation is later used for the inverse kinematics solver.
  </figcaption>
</figure>


  <h3>Inverse Kinematics</h3>
  <p>
    Initial inverse kinematics solutions were explored using trigonometric methods based on the robot’s
    specific geometry. While effective for unit-vector commands, this approach lacked generality.
  </p>
  <p>
    A Jacobian-based inverse kinematics method was ultimately implemented. This approach relies on local
    linearization of the end-effector motion and uses matrix equations to relate differential changes in
    position to changes in joint angles.
  </p>
   <figure>
  <img src="imageJ1.jpg"
       alt="Derivation of the Jacobian"
       width="650">
  <figcaption>
    Hand-derived Jacobian relating joint velocities to Cartesian end-effector velocity.
  </figcaption>
</figure>
   <figure>
  <img src="imageJ2.jpg"
       alt="Derivation of the Jacobian"
       width="650">
  <figcaption>
    simplification of the above, relating change in position to change in angles.
  </figcaption>
</figure>

  <h3>Jacobian Solution and Damping</h3>
  <p>
    Although the system is non-redundant and the Jacobian is theoretically invertible, the inverse problem
    was formulated as a least-squares solution to better align with industry practice and enable future
    expansion. A damping coefficient was introduced to improve numerical stability near singularities.
  </p>
 <figure>
  <img src="imageLeastSquares.jpg"
       alt="Solving the matrix equation derived above as a least squares equation"
       width="650">
  <figcaption>
    Hand-derived Least squares solution for the jacobian matrix equation.
  </figcaption>
</figure>

  <figure>
  <img src="imageDamp.jpg"
       alt="Display of Damped least squares"
       width="650">
  <figcaption>
    The added damping coefficient ensures the eigenvalues of J^T J remain positive. Without this coefficient, Matrix inversion
    becomes numerically unstable near singular regions.
  </figcaption>
</figure> 
  
  <h3>Singularity Detection and Avoidance</h3>
  <p>
    Singularities were detected by monitoring the smallest singular value of the Jacobian matrix. Computing
    a full singular value decomposition at runtime was avoided due to computational constraints; instead,
    eigenvalue-based methods were used to approximate proximity to singular configurations.
  </p>
   <figure>
  <img src="imagePowerIteration.jpg"
       alt="Derivation of least singular value detection"
       width="650">
  <figcaption>
    Hand-derived explanation of how the largest eigenvector of a matrix can be found. to find the smallest Eigenvector and therefore smallest singular
    value it follows from this explanation that solving the augmented matrix [A,w2] and repeating the process would yield such a result.
  </figcaption>
</figure>
  <p>
    Avoidance strategies depend on the detected singularity type. Boundary singularities are handled by
    reversing the desired direction vector, while central singularities are avoided by redirecting motion
    tangentially. Damped least squares further smooths behavior in high-risk configurations.
  </p>

  <!-- Suggestion: Visuals of workspace, singular regions, and trajectories -->
</section>

<section>
  <h2>Control Strategy</h2>
  <p>
    Cartesian-space control was chosen to more closely reflect industrial robotic systems and to enable
    greater mathematical rigor. Velocity-based PID control was implemented to regulate task-space motion.
  </p>
  <p>
    Due to actuator quantization and the absence of strong steady-state disturbances, the integral term
    provided limited benefit in this implementation. Despite these constraints, the control framework
    remains effective when tested in simulation and serves as a foundation for future iterations using
    higher-quality actuators.
  </p>
</section>

<section>
  <h2>Software Implementation</h2>
  <p>
    The system was programmed using Arduino C++ within the Arduino IDE. Libraries such as
    <code>Servo.h</code>, <code>math.h</code>, and <code>BasicLinearAlgebra.h</code> were used to reduce
    implementation overhead and focus development on control logic and system integration.
  </p>
</section>

<section>
  <h2>Challenges and Failure Modes</h2>
  <p>
    Mechanical challenges included designing 3D-printed components with tight dimensional tolerances to
    interface correctly with electronic hardware. Wire management also proved difficult and is not fully
    addressed in the current design.
  </p>
  <p>
    From a control perspective, integrating continuous mathematics into discrete-time embedded software
    required numerical solutions for PID control and singularity detection, introducing additional sources
    of error.
  </p>
</section>

<section>
  <h2>Results</h2>
  <p>
    Experimental testing is ongoing. Preliminary results demonstrate stable Cartesian motion away from
    singular configurations.
  </p>

  <!-- Suggestion: Add trajectory plots, error metrics, or videos -->
</section>

<section>
  <h2>Future Improvements</h2>
  <ul>
    <li>Higher-precision actuators for improved tracking accuracy</li>
    <li>Redesigned mechanical structure with integrated wire management</li>
    <li>Additional degrees of freedom enabling redundancy and null-space optimization</li>
    <li>Migration to a more powerful microcontroller such as an ESP32</li>
    <li>Wireless control</li>
  </ul>
</section>

<section>
  <h2>Skills Demonstrated</h2>
  <ul>
    <li>Forward and inverse kinematics</li>
    <li>Jacobian-based control</li>
    <li>PID control systems</li>
    <li>Embedded systems programming</li>
    <li>C++ / Arduino development</li>
    <li>System integration</li>
  </ul>
</section>

<section>
  <h2>Demo Video</h2>
  <video width="640" controls>
    <source src="assets/videos/robot-demo.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video>
</section>

</body>
</html>

