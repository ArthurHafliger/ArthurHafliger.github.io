<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Robotic Arm Control</title>
</head>
<body>

<nav>
  <a href="index.html">Home</a>
  <a href="projects.html">Projects</a>
</nav>

<h1>Robotic Arm Control System</h1>

<h2>Overview</h2>
<p>
This project implements real-time cartesian control of a 3-DOF robotic arm using a Jacobian based inverse kinematics "solver", PID controls for cartesian commands, and a singularity detection/avoidance system.
</p>

<h2>System Design</h2>
<ul>
  <li>Forward and inverse kinematics</li>
  <li>Jacobian matrix and damped least squares</li>
  <li>Workspace-based controls rather than jointspace-based controls</li>
  <li>PID control for workspace commands with variable time step</li>
  <li>Singularity detection using principles derived from singular value decomposition</li>
  <li>Singularity avoidance using positional awareness and motion redirection</li>
</ul>
<h2>Motivation and Problem Statement</h2>
<p>
The goal of this project was to design and program a robotic arm with rotational joints that could be controlled in the direction of an arbitrary vector in ℝ³,
rather than through direct joint angle commands. This framing shifts the control problem from joint space to task space and requires the use of kinematics, Jacobians,
and feedback control.

I pursued this project to reinforce and integrate concepts from multivariable calculus, linear algebra, statics, and introductory C programming, all of which I had
completed in the preceding semester. Rather than treating these topics independently, the intent was to apply them to a single, constrained physical system.

The system was intentionally limited to an Arduino Uno, two 9g hobby servos, and a single stepper motor. This configuration represents the minimum number of joints 
required to span a three-dimensional workspace while avoiding redundancy and the need for null-space optimization. These constraints simplified the kinematic structure 
while still allowing meaningful exploration of inverse kinematics and singularity behavior.

Hardware limitations significantly influenced the control strategy. The Arduino’s limited computational resources imposed practical constraints on numerical precision 
and algorithmic complexity, while the servos’ integer-degree position resolution introduced quantization error that directly affected end-effector tracking accuracy. 
These limitations highlighted the tradeoffs between theoretical control design and embedded implementation and informed several design decisions discussed later.
</p>
<h2>System Architecture Overview</h2>
<p>
Mechanical System-
  The body of my robot was built from PETG filament out of pieces designed and manufactured by myself. I decided to use a 3d printer for the manufacturing of this project so that
  I could leverage prior experience with SolidWorks and have better control over motor mounts, joint interfaces and general link geometry. As for filament choice, price constraints forced 
  me to choose between PLA and PETG, I chose PETG due to its higher toughness and resistance to brittle failure. While PLA granted higher stiffness, PETGs increased ductility made it 
  preferrable to a system that could experience repeated loadingand future payload expansion.
Electronics and Hardware-
  The control hardware consists of an Arduino Uno microcontroller, two SG90 hobby servos, and a 28BYJ-48 stepper motor. Component selection was constrained by the contents of the electronic starter kit I had
  purchased, intentionally prioritizing accessibility and cost over performance. This constraint forced the control system to operate under limited positional resolution, torque output, and computational capacity,
  making it well-suited for studying the practical limitations of embedded control systems. A solderless breadboard was used to facilitate rapid iteration and debugging during development.
Software Architecture-
  The software was developed iteratively, with an emphasis on modularity and testability. At a high level, the control loop follows this sequence:
    Initialize joint states and system parameters,
    Compute forward kinematics,
    Accept a user-defined direction vector in task space,
    Apply PID control in Cartesian space to reduce positional error,
    Compute joint updates using a damped least-squares Jacobian-based inverse kinematics solver,
    Detect proximity to kinematic singularities,
    Command joint actuators to the updated positions,
Each functional block was designed to be as independent as possible, allowing individual components to be tested in isolation. This architecture enabled debugging and validation of the kinematic and control
logic without requiring the physical hardware to be connected.
</p>
<h2>Mechanical Design</h2>
<p>
The robotic arm consists of three primary mechanical components: a fixed base and two serially connected links, forming a three-degree-of-freedom manipulator.
The base was designed with three supporting legs to ensure stability and includes a central cutout to accommodate the stepper motor shaft. The initial link length
was set to 200 mm but was reduced to approximately 80 mm after preliminary testing revealed torque limitations in the actuators. Link 1 mounts directly to a servo horn
and includes an integrated bracket to house the second servo, enabling rotational motion between the two links. Link 2 was derived from the first link’s geometry but 
modified at the distal end to include a pointer used for visually verifying the estimated end-effector position.
</p>
<h2>Mathmematics/Kinematics</h2>
<p>
  Forward Kinematics Approach
    Formulating forward kinematic equations was done by solving for each cartesian coordinate with respect to the 3 angles of the robot. Below is a derivation of
    the position vector with respect to angles b,a1, and a2.
    -----
  Inverse Kinematics Approach
    Inverse Kinematics for this project was made in many iterations. First testing the method of trigonometry, using the robots specific geometry to create an equation
    that could handle a cartesian command but could only handle a unit vector. 
    ---
    Using properties of Multivariable Calculus and Linear Algebra, I learned and implemented a Jacobian based IK solver. The strength of this method lies in its application
    to all robotic systems. Aside from the mathematical derivation, this method works by "zooming in" to the end effector position and forcing its curved trajectory to appear straight
    (local linearization) and using a matrix equation to transform a change in position vector into a change in angles vector.
    ---
  Jacobian Formulation and Solution Approach
    In the case of this 3 DOF robotic arm the Jacobian matrix is not redundant. As previously mentioned, the nullspace of the Jacobian was not something this bot would ever have to consider.
    Solving the previously mentioned Matrix equation could have been done by method of Cramers Rule or by row reduction method because the Jacobian is invertible, this is only because of non-redundancy.
    To accomodate for further expansion in DOFs and to find an approach more similar to industry, This robot solves the matrix equation as a least squares problem. The least squares problem assumes an 
    inconsistent solution and finds the best approximating vector. In research for this project I found that this least squares solution was often paired with a damping constant. The relevance of this constant
    is more clear in the discussion of singularities.
    ---
  Singularity Detection
    A singularity is a point at which there is no direction of movement available, more formally, when the determinant of the Jacobian Matrix is zero. Such a state can be reached when one or more angles reaches its
    maximum, The end effector touches the origin, and other geometric situations depending on degrees of freedom and link geometry. While it is possible avoid these issues by simply avoiding these geometries, a
    more formal approach comes from singular value decomposition. This method of matrix factorization effectively divides a matrix into 3 sub matrices, two of which describe transformations and one that descirbes the strength
    of these transformations. This "strength" matrix is composed of the singular values of the factored matrix. Finding when the singular values are tiny directly correlates to when a singularity is near. To compute the full singular
    value decomposition at each position would be extremely computationally demanding, a solution to this is to use power iteration. Put into words, if you multiply a matrix by an arbitrary vector and normalize the resulting vector
    then multiply that vector by the matrix again and complete the cycle infinite times, the largest eigenvector of that matrix reveals itself. But since we are interested in the smallest eigenvector we can instead solve the matrix
    with an arbitrary vector via row reduction or cramers rule. With the smallest eigenvector found, we can extract the eigenvalue and take the square root to find the singular value. From here it is a matter of tuning values specific
    to the robot and finding the threshold where a singularity exists.
    ---
  Singularity Avoidance
    With a mathematically sound detection system, avoidance can be broken down into two techniques. Should the robot be approaching the singularity that exists on the edge of the sphere drawn by the workspace, the robot identifies this
    by checking the magnitude of the position vector the end effector occupies and reverses the desired direction vector. Should the robot be approaching the singularity at the center of the workspace, the robot identifies this in the
    same manner but instead redirects motion tangentially by taking the cross product of the direction vector and a K unit vector.
    
    
  
</p>
  
<h2>Demo Video</h2>
<video width="640" controls>
  <source src="assets/videos/robot-demo.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<h2>What Went Wrong</h2>
<p>
Instability occurred near joint limits and Jacobian singularities,
requiring damping and timing corrections.
</p>

</body>
</html>
